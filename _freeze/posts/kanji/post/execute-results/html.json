{
  "hash": "a6ab37ad2813cff33f03ad2d630b648e",
  "result": {
    "markdown": "---\ntitle: 'Loading and Exploring Japanese Kanji Data Using R'\ndate: \"2024-02-27\"\ncategories: ['R', 'data cleaning', 'exploratory']\ndescription: \"Using R to load, explore, describe, and filter data, with a Japanese Kanji database example.\"\nexecute: \n  message: false\n  warning: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n# Introduction\n\nIn this blog post, I'll demonstrate how to use R to load, explore, and filter data from a dataset containing Japanese characters, known as \"kanji\". The datasets were obtained from an online [Kanji database](https://www.kanjidatabase.com/index.php). We'll focus on using the `tidyverse` family of packages to illustrate how to select and filter relevant information efficiently.\n\n# Setup and Loading\n\nTo begin, we need to load necessary libraries and import the datasets:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# | warning: false\n# Loading necessary libraries\nlibrary(tidyverse)\nlibrary(here)\nlibrary(janitor)\n\n# Loading datasets\n\ndata_kanji <- read.csv2(here(\"data/kanji\", \"Kanji_20240227_081842.csv\")) %>% \n  clean_names()\n\ndata_jukugo <- read.csv2(here(\"data/kanji\", \"Jukugo_20240227_081908.csv\")) %>% \n  clean_names()\n```\n:::\n\n\nHere's a breakdown of the code:\n\n* `library(tidyverse)`: We load the `tidyverse` package, which includes `dplyr`, `ggplot2`, and other useful packages.\n* `library(here)`: This package helps manage file paths conveniently.\n* `library(janitor)`: Useful for standardizing variable names and data cleaning.\n* We use `read.csv2()` to import CSV (comma-separated value) files with semicolons (;) as separators. \n* `here(\"data/kanji\", \"Kanji_20240227_081842.csv\")` uses the function `here()` to access the data file, which is saved inside the folders data > kanji.\n* The characters `%>%` are called a \"pipe\" in tidyverse. It can be written simply by pressing Ctrl + Shift + M (in Windows). Basically, it tells R that we want to apply some step to the previous data. In this example, I tell R that I want to use the function `clean_names()` to the data that I've already loaded using `read.csv2()`.\n* `clean_names()` is a `janitor` function that renames all variables in a standard format to make it easier to manipulate. Specifically, `clean_names()` sets all names to lowercase, removes punctuation and symbols, and replaces spaces with underscores.\n\nNow I have two separate datasets: one for kanji (single characters), and one for jukugo (compound words). Let's take a look at them.\n\n# Exploring the data\n\nLet's examine the first few rows of each dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(data_kanji)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    id kanji strokes grade\n1   41    一       1     1\n2  124    乙       1     7\n3 2060    了       2     7\n4 2074    力       2     1\n5 1577    二       2     1\n6 1070    人       2     1\n```\n:::\n\n```{.r .cell-code}\nhead(data_jukugo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   id comp_word frequency          grammatical_feature pronunciation\n1 173      一部     46289 possible to use as an adverb         itibu\n2 234      一般     39274                 general noun         ippan\n3 432      一時     25126 possible to use as an adverb         itizi\n4 461      一番     24155 possible to use as an adverb        itiban\n5 481      一緒     23453    light-verb -suru attached         issyo\n6 529      一致     21388    light-verb -suru attached          itti\n  english_translation position kanji kanji_id\n1            one part        L    一       41\n2             general        L    一       41\n3         one o'clock        L    一       41\n4                best        L    一       41\n5            together        L    一       41\n6         coincidence        L    一       41\n```\n:::\n:::\n\nWe're using the base function `head()`to show the first rows or observations of our datasets. \n\nWe can see that `data_kanji` has four columns or variables: \n\n* `id` shows a unique identification number.\n* `kanji` stores the actual character.\n* `strokes` represents the number of distinct lines or strokes that the character has. \n* `grade` means the official categorization of Kanji by educational year in Japan. Grade 1 includes the easiest or most common kanji, and it goes all up to grade 7. \n\nOn the other hand, `data_jukugo` contains nine variables:\n\n* `id` is the identification number for jukugos.\n* `comp_word` is the actual word.\n* `frequency` is a measure of how many times each jukugo appear in a selected corpus of Japanese literature (extracted from Japanese newspapers).\n* `grammatical_feature` gives us more context of how the word is used in grammatical terms.\n* `pronunciation` tells us the pronunciation in \"romaji\", or the Latin alphabet.\n* `english_translation` stores the English translation.\n\nThe last three variables in `data_jukugo` describes the kanji which is part of the jukugo:\n\n* `position` tells us if the kanji is used in left position \"L\" or right position \"R\".\n* `kanji` shows the kanji used in the jukugo. The first rows all show jukugos composed with the kanji \"一\".\n* `kanji_id` is the identification number of the kanji part. We can use this id to link `data_jukugo` with `data_kanji` if we want to.\n\nAnother way of looking into a dataset is to explore how each variable is encoded:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(data_kanji)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 2,136\nColumns: 4\n$ id      <int> 41, 124, 2060, 2074, 1577, 1070, 1584, 829, 359, 1647, 1903, 1…\n$ kanji   <chr> \"一\", \"乙\", \"了\", \"力\", \"二\", \"人\", \"入\", \"七\", \"九\", \"八\", \"…\n$ strokes <int> 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3,…\n$ grade   <int> 1, 7, 7, 1, 1, 1, 1, 1, 1, 1, 7, 3, 1, 2, 1, 2, 6, 7, 6, 1, 2,…\n```\n:::\n\n```{.r .cell-code}\nglimpse(data_jukugo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 52,791\nColumns: 9\n$ id                  <int> 173, 234, 432, 461, 481, 529, 937, 1465, 1521, 156…\n$ comp_word           <chr> \"一部\", \"一般\", \"一時\", \"一番\", \"一緒\", \"一致\", \"…\n$ frequency           <int> 46289, 39274, 25126, 24155, 23453, 21388, 12477, 7…\n$ grammatical_feature <chr> \"possible to use as an adverb\", \"general noun\", \"p…\n$ pronunciation       <chr> \"itibu\", \"ippan\", \"itizi\", \"itiban\", \"issyo\", \"itt…\n$ english_translation <chr> \"one part\", \"general\", \"one o'clock\", \"best\", \"tog…\n$ position            <chr> \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", …\n$ kanji               <chr> \"一\", \"一\", \"一\", \"一\", \"一\", \"一\", \"一\", \"一\", \"…\n$ kanji_id            <int> 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41…\n```\n:::\n:::\n\n\nThe `glimpse()` function allows us to quickly glance at the data structure. \n\nWe can see that `data_kanji` has 2,136 rows or observations and 4 columns or variables. We also see the first values of each of its four variables. More importantly, we can see which data type each variable stores. The `kanji` variable has `<chr>` type, which means \"character\" or \"text\", while the rest of variables have `<int>` type, which means \"integer\" number, or a round number. R automatically detects the data types when importing data using functions like `read.csv2()`.\n\nRegarding `data_jukugo`, it has 52,791 rows and 9 columns, of which 3 have `<int>` type, and 6 have `<char>` type.\n\n# Manipulating the data\n\nNow that I'm familiarized with this dataset, it's useful to lay down what my analysis plan is. In other words, what do I want to learn from this data? In this case, I want to be able to find words (jukugo) that only contain kanji from a selected list of kanji that I'm learning. So, for example, if I only know kanjis 一, 人, and 十, I want to know all the possible combinations of these three kanjis.\n\nFor this exercise, I'm interested in separate jukugos in two parts: the left kanji, and the right kanji. The dataset already has half of this information, but sometimes it tells us the left kanji, and sometimes the right kanji (usually, the simplest kanji of the two). I want to get sistematically both left and right kanjis, so I'll create new variables called `kanji_left` and `kanji_right`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_jukugo <- data_jukugo %>% \n  mutate(kanji_left = substr(comp_word, 1, 1),\n         kanji_right = substr(comp_word, 2, 2))\n\nglimpse(data_jukugo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 52,791\nColumns: 11\n$ id                  <int> 173, 234, 432, 461, 481, 529, 937, 1465, 1521, 156…\n$ comp_word           <chr> \"一部\", \"一般\", \"一時\", \"一番\", \"一緒\", \"一致\", \"…\n$ frequency           <int> 46289, 39274, 25126, 24155, 23453, 21388, 12477, 7…\n$ grammatical_feature <chr> \"possible to use as an adverb\", \"general noun\", \"p…\n$ pronunciation       <chr> \"itibu\", \"ippan\", \"itizi\", \"itiban\", \"issyo\", \"itt…\n$ english_translation <chr> \"one part\", \"general\", \"one o'clock\", \"best\", \"tog…\n$ position            <chr> \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", …\n$ kanji               <chr> \"一\", \"一\", \"一\", \"一\", \"一\", \"一\", \"一\", \"一\", \"…\n$ kanji_id            <int> 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41…\n$ kanji_left          <chr> \"一\", \"一\", \"一\", \"一\", \"一\", \"一\", \"一\", \"一\", \"…\n$ kanji_right         <chr> \"部\", \"般\", \"時\", \"番\", \"緒\", \"致\", \"定\", \"連\", \"…\n```\n:::\n:::\n\n\nLet's explain the code:\n\n* `mutate()` is the `dplyr` function used to create or change variables. Here, I create two variables, `kanji_left` and `kanji_right`.\n* `substr()` is a base function that subtracts a string of text from a character variable. `substr(comp_word, 1, 1)` means to subtract only the first character, and `substr(comp_word, 2, 2)` gets the second character.\n\nAlright, now I need to define the list of kanjis that I'm currently learning. This I need to do it manually, but later I'll explain how to do it more dinamically.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkanji_learning <- c(\"一\", \"二\", \"三\", \"王\", \"玉\", \"十\", \"五\")\n```\n:::\n\n\nLastly, I'll tell R to filter the jukugos that only include kanji that are on my learning list. I also want to sort the jukugos from more to less used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\njukugo_learning <- data_jukugo %>% \n  filter(kanji_left %in% kanji_learning, kanji_right %in% kanji_learning) %>% \n  arrange(desc(frequency))\n\nhead(jukugo_learning)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     id comp_word frequency          grammatical_feature pronunciation\n1 17059      二三        32 possible to use as an adverb         nisan\n2 17059      二三        32 possible to use as an adverb         nisan\n3 20330      三一        12                 general noun        sanpin\n4 20330      三一        12                 general noun        sanpin\n5 23443      一一         4 possible to use as an adverb        itiiti\n6 23443      一一         4 possible to use as an adverb        itiiti\n  english_translation position kanji kanji_id kanji_left kanji_right\n1        two or three        L    二     1577         二          三\n2        two or three        R    三      744         二          三\n3 low-ranking samurai        R    一       41         三          一\n4 low-ranking samurai        L    三      744         三          一\n5          one-by-one        L    一       41         一          一\n6          one-by-one        R    一       41         一          一\n```\n:::\n:::\n\nThe `filter()` function selects rows based on one or more conditions. I've passed two conditions: that `kanji_left` is included in the `kanji_learning` \"list\" (in R we'd call this a vector, not a list), and that `kanji_right` is also included in `kanji_learning`. The term \"is included in\" is represented in R with the operand `%in%`.\n\nThe `arrange()` function reorders the rows based on one or more variables. I've passed the argument `desc(frequency)` because I want the words to be sorted in descending order of frequency (from more to less frequency).\n\nNow, something odd has happened: now we have two copies of each jukugo. These are complete duplicates in the dataset, with the only difference of which kanji appears in the variables `position`, `kanji`, and `kanji_id`. For example, \"nisan\" (二三) appears twice, one with `position` L, `kanji` 二, and `kanji_id` 1577, and another with `position` R, `kanji` 三, and `kanji_id` 744. This is somethin that I didn't see first time I explored the dataset.\n\nI could have done things differently. Instead of splitting the jukugos manually, I could have performed a \"self-join\" of the duplicated rows. But one cool thing about data cleaning and analysis is that there are always different ways to reach the same goal. It's an iterative process, and by trial and error I can learn a lot and find alternative methods of doing things.\n\nMoving forward, since I'm only interested in keeping one record of each jukugo, I can drop these duplicates. Aditionally, I'll keep only the variables I'm interested in.\n\n\n::: {.cell}\n\n```{.r .cell-code}\njukugo_learning <- jukugo_learning %>% \n  select(id, comp_word, frequency, grammatical_feature, pronunciation, english_translation, kanji_left, kanji_right) %>%\n  distinct()\n\nhead(jukugo_learning)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     id comp_word frequency          grammatical_feature pronunciation\n1 17059      二三        32 possible to use as an adverb         nisan\n2 20330      三一        12                 general noun        sanpin\n3 23443      一一         4 possible to use as an adverb        itiiti\n4 25773      二王         2                 general noun          nioo\n          english_translation kanji_left kanji_right\n1                two or three         二          三\n2         low-ranking samurai         三          一\n3                  one-by-one         一          一\n4 the two guardian Deva kings         二          王\n```\n:::\n:::\n\n\nI've used two new `dplyr` functions: `select()` keeps some columns or variables, and `distinct()` keeps only non-duplicated rows.\n\nThe final result contains four distinct jukugos: 二三, 三一, 一一, and 二王. All of them are very low-frequency, with the most common of them appearing only 32 times.\n\n# Next step: making it interactive\n\nSo far, I have created a code that filters Japanese kanji words based on whatever Kanji components I want. However, the whole process would be nicer if I had a way of selecting the data interactivelly, maybe pressing some buttons. We can do just that using R Shiny applications. But that's for another day!\n\n# References\n\n* [Kanji database](https://www.kanjidatabase.com/index.php).",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}