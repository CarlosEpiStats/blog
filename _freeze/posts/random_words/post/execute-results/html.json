{
  "hash": "48cf746be045719a1fba3e4e0fd59c43",
  "result": {
    "markdown": "---\ntitle: \"Generating Random City Names Based on Syllable Formation Rules\"\ndate: \"2024-07-15\"\ncategories: ['R', 'strings', 'functions', 'creative project']\ndescription: \"A step-by-step guide on how to generate random city names using syllable-based rules in R.\"\nexecute: \n  message: false\n  warning: false\neditor_options: \n  chunk_output_type: console\nformat: \n  html\n---\n\n\n# Introduction\n\nIn this blog post, we'll explore how to generate random city names by applying various syllable-based rules to the names of municipalities in the Province of Alicante, Spain. We will be using several functions to transform and manipulate strings in R.\n\n# Motivation\n\nThis post aims to create fictional names for locations, such as those found in fantasy novels, that resemble Spanish words but do not actually exist. This method can also be applied to generate names for characters or invent unique words for various creative projects. The main challenge is implementing rules for syllable formation, which are the building blocks of word generation, and then finding combinations of syllables present in real words to replicate something similar. By doing so, we can produce names that sound authentic yet are entirely new.\n\n# Load Libraries\n\nFirst, we load the necessary libraries.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(rvest)\nlibrary(ggwordcloud)\n\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.4.1 (2024-06-14 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: Europe/Madrid\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] ggwordcloud_0.6.2 rvest_1.0.4       lubridate_1.9.3   forcats_1.0.0    \n [5] stringr_1.5.1     dplyr_1.1.4       purrr_1.0.2       readr_2.1.5      \n [9] tidyr_1.3.1       tibble_3.2.1      ggplot2_3.5.1     tidyverse_2.0.0  \n\nloaded via a namespace (and not attached):\n [1] gtable_0.3.5      jsonlite_1.8.8    compiler_4.4.1    Rcpp_1.0.12      \n [5] tidyselect_1.2.1  xml2_1.3.6        png_0.1-8         scales_1.3.0     \n [9] yaml_2.3.9        fastmap_1.2.0     R6_2.5.1          generics_0.1.3   \n[13] knitr_1.48        htmlwidgets_1.6.4 munsell_0.5.1     pillar_1.9.0     \n[17] tzdb_0.4.0        rlang_1.1.4       utf8_1.2.4        stringi_1.8.4    \n[21] xfun_0.45         timechange_0.3.0  cli_3.6.3         withr_3.0.0      \n[25] magrittr_2.0.3    gridtext_0.1.5    digest_0.6.36     grid_4.4.1       \n[29] rstudioapi_0.16.0 hms_1.1.3         lifecycle_1.0.4   vctrs_0.6.5      \n[33] evaluate_0.24.0   glue_1.7.0        fansi_1.0.6       colorspace_2.1-0 \n[37] httr_1.4.7        rmarkdown_2.27    tools_4.4.1       pkgconfig_2.0.3  \n[41] htmltools_0.5.8.1\n```\n:::\n:::\n\n\n# Import and Clean Data\n\nWe start by importing the data of municipalities in the Province of Alicante from Wikipedia and cleaning it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Import data of municipalities in Alacant Province -------------------------------------------------------------\nhtml_alacant <- read_html(\"https://es.wikipedia.org/wiki/Anexo:Municipios_de_la_provincia_de_Alicante\")\n\ncities_alicante <- html_alacant |>\n  html_element(\".wikitable\") |>\n  html_table() |>\n  select(name = `Nombre en castellano`)\n\nhead(cities_alicante)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 1\n  name          \n  <chr>         \n1 Adsubia       \n2 Agost         \n3 Agres         \n4 Aguas de Busot\n5 Albatera      \n6 Alcalalí      \n```\n:::\n:::\n\n\n# Functions\n\n## Pre-process Words\n\nThis function transforms the names into a format suitable for syllable extraction. It converts the names to lowercase, replaces spaces and commas, and substitutes specific letter combinations with symbols.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nletter_to_symbol <- function(df, var) {\n  df |>\n    mutate(\n      palabras = str_to_lower({{ var }}),\n      palabras = str_replace(palabras, \"(.*), (.*)\", \"\\\\2 \\\\1\"),\n      palabras = str_replace_all(palabras, \" \", \"_\"),\n      palabras = str_replace_all(palabras, \",\", \"\"),\n      palabras = str_replace_all(palabras, \"ch\", \"ʧ\"),\n      palabras = str_replace_all(palabras, \"rr\", \"ʀ\"),\n      palabras = str_replace_all(palabras, \"qu\", \"q\"),\n      palabras = str_replace_all(palabras, \"ll\", \"ʝ\"),\n      palabras = str_replace_all(palabras, \"c([aou])\", \"k\\\\1\")\n    )\n}\n```\n:::\n\n\n\n## Apply Syllable-Based Rules\n\nThis function applies a regex rule to separate syllables based on predefined patterns. It detects and splits words according to the rule, handling cases where the rule does not apply.\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply_rule <- function(df, regex) {\n  df |>\n    mutate(\n      rule = str_detect(palabras, regex),\n      syllable = as_tibble(str_match(palabras, regex)[, -1], .name_repair = \"minimal\")\n    ) |>\n    unnest_wider(syllable, names_sep = \"_\") |>\n    pivot_longer(\n      cols = starts_with(\"syllable\"),\n      values_to = \"silabas\",\n      names_to = \"norma\"\n    ) |>\n    mutate(\n      silabas = ifelse(rule == FALSE & norma == \"syllable_1\", palabras, silabas)\n    ) |>\n    filter(!is.na(silabas) & silabas != \"\") |>\n    select(\n      name,\n      palabras = silabas\n    )\n}\n```\n:::\n\n\n## Apply Rules in Loop\n\nThis function repeatedly applies the given regex rule until no more changes occur in the dataset, ensuring all possible syllable separations are handled.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloop_apply_rule <- function(df, regex) {\n  loop_controller <- TRUE\n  while (loop_controller == TRUE) {\n    previous_nrow <- nrow(df)\n    df <- apply_rule(df, regex)\n    new_nrow <- nrow(df)\n    loop_controller <- ifelse(previous_nrow == new_nrow, FALSE, TRUE)\n  }\n  df\n}\n```\n:::\n\n\n## Revert Symbols to Original Letters\n\nThis function reverses the symbol transformations applied by `letter_to_symbol`, converting symbols back to their original letter combinations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsymbol_to_letter <- function(df, var) {\n  df |>\n    mutate(\n      {{ var }} := str_replace_all({{ var }}, \"_\", \" \"),\n      {{ var }} := str_replace_all({{ var }}, \"ʧ\", \"ch\"),\n      {{ var }} := str_replace_all({{ var }}, \"ʝ\", \"ll\"),\n      {{ var }} := str_replace_all({{ var }}, \"ʀ\", \"rr\"),\n      {{ var }} := str_replace_all({{ var }}, \"q\", \"qu\"),\n      {{ var }} := str_replace_all({{ var }}, \"k([aou])\", \"c\\\\1\")\n    )\n}\n```\n:::\n\n\n## Spanish Syllable Rules\n\nHere, we define the regex rules for syllable separation. These are based on Spanish rules for syllable separation (inspiration from [this document](http://elies.rediris.es/elies4/Fon2.htm)).\n\nThese rules are completely dependent on the language we are trying to imitate.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnorma_0a <- regex(\"(^.+)(_[dy].*_)(.+$)\") # handle separation words, such as \"de\", \"de los\", etc.\nnorma_0b <- regex(\"(^[^_]+_)(.+)\") # handle separation words, such as \"de\", \"de los\", etc.\nnorma_1 <- regex(\"(.*[aeiouáéíóú])([^_aeiouáéíóú][aeiouáéíóú].*)\") # VCV -> V-CV\nnorma_2a <- regex(\"(.*)([pkbgf][rl].*)\") # C1 C2 -> - C1 C2 (obstruyente + líquida)\nnorma_2b <- regex(\"(.*)([dt][r].*)\") # C1 C2 -> - C1 C2 (obstruyente + líquida)\nnorma_2c <- regex(\"(.*[^_aeiouáéíóú])([^_aeiouáéíóúrl][^_].*)\") # C1 C2 -> C1 - C2 \nnorma_2d <- regex(\"(.*[^_aeiouáéíóúpkbgfdt])([rl].+)\") # C1 C2 -> C1 - C2 \nnorma_2e <- regex(\"(.*[^_aeiouáéíóúpkbgf])([l].+)\") # C1 C2 -> C1 - C2 \nnorma_5 <- regex(\"(.*[aeo])([aeo].*)\") # V1 V2 -> V1 - V2 (vocales altas)\nnorma_6a <- regex(\"(.*[íú])([aeiou].*)\") # V1 V2 -> V1 - V2 (hiatos)\nnorma_6b <- regex(\"(.*[aeiou])([íú].*)\") # V1 V2 -> V1 - V2 (hiatos)\n```\n:::\n\n\n## Separate Words into Syllables\n\nThis function applies all the syllable separation rules to the names and converts them back from symbols to letters. It also labels each syllable's position in the word.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames_to_syllables <- function(df) {\n  df |>\n    letter_to_symbol(name) |>\n    loop_apply_rule(norma_0a) |>\n    loop_apply_rule(norma_0b) |>\n    loop_apply_rule(norma_1) |>\n    loop_apply_rule(norma_2a) |>\n    loop_apply_rule(norma_2b) |>\n    loop_apply_rule(norma_2c) |>\n    loop_apply_rule(norma_2d) |>\n    loop_apply_rule(norma_2e) |>\n    loop_apply_rule(norma_5) |>\n    loop_apply_rule(norma_6a) |>\n    loop_apply_rule(norma_6b) |>\n    symbol_to_letter(palabras) |>\n    group_by(name) |>\n    mutate(\n      posicion = case_when(\n        row_number() == 1 ~ \"inicio\",\n        row_number() == n() ~ \"final\",\n        TRUE ~ \"medio\"\n      )\n    ) |>\n    ungroup() |>\n    rename(silaba = palabras)\n}\n```\n:::\n\n\n## Create Randomly-Generated City Name\n\nThis function generates random city names by selecting syllables based on their frequency and position within existing names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_random_name <- function(df_syllables_per_word, df_syllables_freq, length = 1, beginning = \"\") {\n  new_names_vector <- \"\"\n  for (x in 1:length) {\n    n_syllables <- df_syllables_per_word |>\n      slice_sample(n = 1) |>\n      pull(n)\n    new_name <- \"\"\n    for (i in 1:n_syllables) {\n      place <- case_when(\n        i == 1 ~ \"inicio\",\n        i == n_syllables ~ \"final\",\n        TRUE ~ \"medio\"\n      )\n      new_name[i] <- df_syllables_freq |>\n        filter(posicion == place) |>\n        slice_sample(n = 1, weight_by = n) |>\n        pull(silaba)\n    }\n    new_name <- str_c(beginning, str_flatten(new_name)) |> str_to_title()\n    new_names_vector[x] <- new_name\n  }\n  new_names_vector\n}\n```\n:::\n\n\n## Putting All Together\n\nCombine all steps into a single function to generate random city names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_city_names <- function(df, length = 1, beginning = \"\") {\n  syllables <- names_to_syllables(df)\n  syllables_freq <- syllables |> count(posicion, silaba)\n  syllables_per_word <- syllables |> count(name)\n  create_random_name(syllables_per_word, syllables_freq, length = length, beginning = beginning)\n}\n```\n:::\n\n\n# Applying to Alicante Cities Data\n\nTransform the Alicante municipalities' names into syllables.\n\n## Names to Syllables\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsilabas <- cities_alicante |> names_to_syllables()\nhead(silabas)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  name    silaba posicion\n  <chr>   <chr>  <chr>   \n1 Adsubia ad     inicio  \n2 Adsubia su     medio   \n3 Adsubia bia    final   \n4 Agost   a      inicio  \n5 Agost   gost   final   \n6 Agres   a      inicio  \n```\n:::\n:::\n\n\n\n## Syllable Frequency\n\nCalculate the frequency of each syllable and its position.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsilabas_freq <- silabas |> count(posicion, silaba)\nhead(silabas_freq)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  posicion silaba     n\n  <chr>    <chr>  <int>\n1 final    a          3\n2 final    ba         2\n3 final    beig       1\n4 final    ber        1\n5 final    bi         2\n6 final    bia        1\n```\n:::\n\n```{.r .cell-code}\nsilabas_freq |> \n  filter(n >= 2) |>\n  ggplot(aes(label = silaba, size = n)) +\n  scale_size_area(max_size = 20) +\n  geom_text_wordcloud() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/syllables-freq-1.png){width=672}\n:::\n:::\n\n\n## Syllables per Word \n\nCount the number of syllables per name and visualize the distribution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsilabas_por_palabra <- silabas |> count(name)\n\nggplot(silabas_por_palabra, aes(x = n)) +\n  geom_bar() +\n  theme_classic() +\n  scale_y_continuous(expand = c(0, 0)) +\n  scale_x_continuous(breaks = 1:8) +\n  labs(\n    x = \"Number of syllables per City Name\",\n    y = \"Count\"\n  )\n```\n\n::: {.cell-output-display}\n![](post_files/figure-html/syllables-per-word-1.png){width=672}\n:::\n:::\n\n\n## Generate Random Names\n\nGenerate a set of random city names based on the Alicante data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\ncreate_city_names(cities_alicante, length = 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Semancent\"            \"Pi De Ja\"             \"Ojória\"              \n [4] \"Cabalisot\"            \"Ate\"                  \"Alniecogost\"         \n [7] \"Mondacañedes\"         \"Amataviedro\"          \"San  De Las Na\"      \n[10] \"Parchenes\"            \"Banar\"                \"Pora\"                \n[13] \"Befajuanjachell\"      \"Danipi\"               \"Beniarra De Nas\"     \n[16] \"Comarnigo\"            \"Biarrate\"             \"Algra\"               \n[19] \"Benichell\"            \"No De Minedanillenes\"\n```\n:::\n:::\n\n\n# Challenges Left\n\nDespite the progress made, several challenges remain. Post-processing errors, such as double blank spaces, multiple accents in a single word, and overly long or difficult-to-pronounce words, need to be addressed. Future improvements could involve using two-syllable combinations instead of single-syllable building blocks, which would create more natural-sounding names at the expense of reduced variety.\n\n# Conclusion\n\nIn this post, we demonstrated how to generate random city names by applying syllable-based rules to the names of municipalities in Alicante, Spain. By following these steps, you can create your own set of random names for any dataset of city names.\n\n# References\n\n-   [Municipios de la Provincia de Alicante](https://es.wikipedia.org/wiki/Anexo:Municipios_de_la_provincia_de_Alicante)\n-   [Reglas de silabación del castellano](http://elies.rediris.es/elies4/Fon2.htm)",
    "supporting": [
      "post_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}