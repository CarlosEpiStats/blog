{
  "hash": "875498990bf0df28e390fad4231076b6",
  "result": {
    "markdown": "---\ntitle: \"Mastering Regular Expressions: Dealing with String Data in R, Part I\"\ndate: \"2024-06-19\"\ncategories: ['R', 'tidyverse', 'regex', 'string', 'text']\ndescription: \"Solving R for Data Science (2ed) Exercises\"\nexecute: \n  message: false\n  warning: false\neditor_options: \n  chunk_output_type: console\nformat: \n  html\n---\n\n\n# Introduction\n\nRegular expressions (regex) are a powerful tool for working with string data in R. They might seem complex at first, but with some practice, they can become an invaluable part of your data science toolkit. In this blog post, we will tackle the first three exercises from the [\"R for Data Science\" (2nd edition) book](https://r4ds.hadley.nz/) on regular expressions. Let's dive into the world of regex and see how we can manipulate and search text data effectively.\n\n# Setting Up\n\nFirst, let's load the necessary library:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n# Exercise 1: Matching Literal Strings\n\n**Question:** How would you match the literal string `\"'\\`? How about `\"$^$\"`?\n\n**Solution:**\n\nTo match these literal strings, we need to handle special characters carefully. Special characters in regex need to be escaped with a backslash (`\\`). Here’s how we can do it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring_1 <- r\"(\"'\\)\"\nstring_2 <- r\"(\"$^$\")\"\n\n# Visualize the strings\nstr_view(c(string_1, string_2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ \"'\\\n[2] │ \"$^$\"\n```\n:::\n\n```{.r .cell-code}\n# Using escape backslashes\nstr_view(string_1, \"\\\"\\'\\\\\\\\\") # Matches \"'\\\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ <\"'\\>\n```\n:::\n\n```{.r .cell-code}\nstr_view(string_2, \"\\\"\\\\$\\\\^\\\\$\\\"\") # Matches \"$^$\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ <\"$^$\">\n```\n:::\n\n```{.r .cell-code}\n# Using character classes\nstr_view(string_2, \"\\\"[$]\\\\^[$]\\\"\") # Matches \"$^$\" using character classes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ <\"$^$\">\n```\n:::\n\n```{.r .cell-code}\n# Using raw strings (simplifies escaping)\nstr_view(string_1, r\"(\"'\\\\)\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ <\"'\\>\n```\n:::\n\n```{.r .cell-code}\nstr_view(string_2, r\"(\"\\$\\^\\$\")\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ <\"$^$\">\n```\n:::\n:::\n\n\n## Exercise 2: Why Patterns Don't Match a Backslash\n\n**Question:** Explain why each of these patterns don't match a `\\`:\n\n-   \"\\\\\"\n\n-   \"\\\\\\\\\"\n\n-   \"\\\\\\\\\\\\\"\n\n**Solution:**\n\nLet's break down why these patterns fail to match a single backslash:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring <- r\"(\\)\"\nstr_view(string)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ \\\n```\n:::\n\n```{.r .cell-code}\n# str_view(string, \"\\\") \n# This escapes the \", and the code is left incomplete\n\n# str_view(string, \"\\\\\") \n# This throws an error \"Unrecognized backslash escape secuence\", \\\\ is used to escape special characters, but none follows it\n\n# str_view(string, \"\\\\\\\")\n# This escapes the \", and the code is left incomplete\n\n# Correct way:\nstr_view(string, \"\\\\\\\\\") # This works because \\\\ in regex represents a literal backslash.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ <\\>\n```\n:::\n\n```{.r .cell-code}\n# Using raw strings (simplifies escaping):\nstr_view(string, r\"(\\\\)\") # Only needs to escape the backslash once.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ <\\>\n```\n:::\n:::\n\n\n## Exercise 3: Searching Within a Corpus\n\n**Question:** Given the corpus of common words in `stringr::words`, create regular expressions that find all words that:\n\na\\. Start with \"y\".\n\nb\\. Don't start with \"y\".\n\nc\\. End with \"x\".\n\nd\\. Are exactly three letters long. (Don't cheat by using `str_length()`!)\n\ne\\. Have seven letters or more.\n\nf\\. Contain a vowel-consonant pair.\n\ng\\. Contain at least two vowel-consonant pairs in a row.\n\nh\\. Only consists of repeated vowel-consonant pairs.\n\n**Solution:**\n\nHere are the regex patterns to match each condition:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visualize all words\nstr_view(words)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] │ a\n [2] │ able\n [3] │ about\n [4] │ absolute\n [5] │ accept\n [6] │ account\n [7] │ achieve\n [8] │ across\n [9] │ act\n[10] │ active\n[11] │ actual\n[12] │ add\n[13] │ address\n[14] │ admit\n[15] │ advertise\n[16] │ affect\n[17] │ afford\n[18] │ after\n[19] │ afternoon\n[20] │ again\n... and 960 more\n```\n:::\n\n```{.r .cell-code}\n# a. Start with \"y\".\nstr_view(words, \"^y\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[975] │ <y>ear\n[976] │ <y>es\n[977] │ <y>esterday\n[978] │ <y>et\n[979] │ <y>ou\n[980] │ <y>oung\n```\n:::\n\n```{.r .cell-code}\n# b. Don't start with \"y\".\nstr_view(words[!str_detect(words, \"^y\")])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] │ a\n [2] │ able\n [3] │ about\n [4] │ absolute\n [5] │ accept\n [6] │ account\n [7] │ achieve\n [8] │ across\n [9] │ act\n[10] │ active\n[11] │ actual\n[12] │ add\n[13] │ address\n[14] │ admit\n[15] │ advertise\n[16] │ affect\n[17] │ afford\n[18] │ after\n[19] │ afternoon\n[20] │ again\n... and 954 more\n```\n:::\n\n```{.r .cell-code}\n# c. End with \"x\".\nstr_view(words, \"x$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[108] │ bo<x>\n[747] │ se<x>\n[772] │ si<x>\n[841] │ ta<x>\n```\n:::\n\n```{.r .cell-code}\n# d. Are exactly three letters long. (Don't cheat by using str_length()!)\nstr_view(words, \"^[a-z]{3}$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [9] │ <act>\n [12] │ <add>\n [22] │ <age>\n [24] │ <ago>\n [26] │ <air>\n [27] │ <all>\n [38] │ <and>\n [41] │ <any>\n [51] │ <arm>\n [54] │ <art>\n [56] │ <ask>\n [68] │ <bad>\n [69] │ <bag>\n [73] │ <bar>\n [82] │ <bed>\n [89] │ <bet>\n [91] │ <big>\n [94] │ <bit>\n[108] │ <box>\n[109] │ <boy>\n... and 90 more\n```\n:::\n\n```{.r .cell-code}\n# e. Have seven letters or more.\nstr_view(words, \"^[a-z]{7,}$\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [4] │ <absolute>\n [6] │ <account>\n [7] │ <achieve>\n[13] │ <address>\n[15] │ <advertise>\n[19] │ <afternoon>\n[21] │ <against>\n[31] │ <already>\n[32] │ <alright>\n[34] │ <although>\n[36] │ <america>\n[39] │ <another>\n[43] │ <apparent>\n[46] │ <appoint>\n[47] │ <approach>\n[48] │ <appropriate>\n[53] │ <arrange>\n[57] │ <associate>\n[61] │ <authority>\n[62] │ <available>\n... and 198 more\n```\n:::\n\n```{.r .cell-code}\n# f. Contain a vowel-consonant pair.\nstr_view(words, \"[aeiou][^aeiou]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [2] │ <ab>le\n [3] │ <ab>o<ut>\n [4] │ <ab>s<ol><ut>e\n [5] │ <ac>c<ep>t\n [6] │ <ac>co<un>t\n [7] │ <ac>hi<ev>e\n [8] │ <ac>r<os>s\n [9] │ <ac>t\n[10] │ <ac>t<iv>e\n[11] │ <ac>tu<al>\n[12] │ <ad>d\n[13] │ <ad>dr<es>s\n[14] │ <ad>m<it>\n[15] │ <ad>v<er>t<is>e\n[16] │ <af>f<ec>t\n[17] │ <af>f<or>d\n[18] │ <af>t<er>\n[19] │ <af>t<er>no<on>\n[20] │ <ag>a<in>\n[21] │ <ag>a<in>st\n... and 924 more\n```\n:::\n\n```{.r .cell-code}\n# g. Contain at least two vowel-consonant pairs in a row.\nstr_view(words, \"([aeiou][^aeiou]){2,}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [4] │ abs<olut>e\n [23] │ <agen>t\n [30] │ <alon>g\n [36] │ <americ>a\n [39] │ <anot>her\n [42] │ <apar>t\n [43] │ app<aren>t\n [61] │ auth<orit>y\n [62] │ ava<ilab>le\n [63] │ <awar>e\n [64] │ <away>\n [70] │ b<alan>ce\n [75] │ b<asis>\n [81] │ b<ecom>e\n [83] │ b<efor>e\n [84] │ b<egin>\n [85] │ b<ehin>d\n [87] │ b<enefit>\n[119] │ b<usines>s\n[143] │ ch<arac>ter\n... and 149 more\n```\n:::\n\n```{.r .cell-code}\n# h. Only consists of repeated vowel-consonant pairs.\nstr_view(words, \"^([aeiou][^aeiou])\\\\1+$\") # No matches, let's try a positive match\n\n# Test with known patterns\npattern <- \"^([aeiou][^aeiou])\\\\1+$\"\npos <- c(\"anananan\", \"erer\")\nneg <- c(\"nananana\", \"erere\", \"ananerer\")\n\nstr_view(pos, pattern)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] │ <anananan>\n[2] │ <erer>\n```\n:::\n\n```{.r .cell-code}\nstr_view(neg, pattern)\n# It seems to work, there are no words with this pattern in stringr::words\n```\n:::\n\n\nWith these exercises, we’ve demonstrated how regular expressions can be used to manipulate and search text data in R. Whether you are searching for specific patterns or validating text data, regex provides a robust solution for your string processing needs.\n\nSee you soon in Part II of these exercises.\n\nHappy regexing!\n\n# References\n\n-   R for Data Science (2ed), written by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. <https://r4ds.hadley.nz/>\n\n-   Wickham H, Averick M, Bryan J, Chang W, McGowan LD, François R, Grolemund G, Hayes A, Henry L, Hester J, Kuhn M, Pedersen TL, Miller E, Bache SM, Müller K, Ooms J, Robinson D, Seidel DP, Spinu V, Takahashi K, Vaughan D, Wilke C, Woo K, Yutani H (2019). \"Welcome to the tidyverse.\" *Journal of Open Source Software*, *4*(43), 1686. doi:10.21105/joss.01686 <https://doi.org/10.21105/joss.01686>.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}